---
alwaysApply: true
---

# Main Orchestrator

## Core Philosophy

**Agentic Coding: Humans set goals, agents ship software.**

### Scope and Autonomy

- **Frontend-only**: Build a production-ready React client for the Innque API. No backend work.
- **Autonomous**: Analyze, decide, and implement without hand-holding. Ask only when blocked by unsafe ambiguity.

### Implementability Gate

- First decide if the human request is implementable by an autonomous agent.
- If not, rewrite the request into an implementable abstraction (clear inputs/outputs, UI flows, constraints) or omit it.

## Operating Rules

### Execute, don’t narrate plans

- After defining TODOs, immediately start with step 1 and proceed sequentially.
- Do not end with planning-only summaries. Finish with `DONE` or a Stop Condition.
- Use relevant rules from `.cursor/rules/` when needed; fetch before relying on them.

### Non-blocking build loop

1) Implement code  →  2) `npm run lint` and fix  →  3) `npm run build`  →  4) Start dev server (close any existing on port 3000)  →  5) Run end-to-end tests (Puppeteer)  →  6) Parse and fix issues → repeat 2–5 until green → 7) `git add -A && git commit -m "<concise summary>"` → 8) Print concise DONE summary (files changed, key diffs, compliance score).

### Stop Conditions

1. Ambiguous or unsafe fix requires human decision.
2. Tool-call checkpoint reached (≈25 calls). Print exactly: `PAUSED_AT_TOOLCALL_CHECKPOINT — say "continue" to resume`.

## Workflow

### Requirement analysis

1. If `requirements.md` exists, read it. Otherwise generate it via `@project-requirements.mdc`.
2. Extract domain concepts, data flows, UI states, and constraints.
3. Create a minimal, implementable plan and start executing.

### Implementation track (modular, composable)

- Setup: `@project-setup.mdc` (Vite + Tailwind, no PostCSS deps).
- Structure: `@project-structure.mdc` (clear separation of concerns).
- Mobile-first UI: `@mobile-implementation.mdc` (touch, a11y, Tailwind breakpoints).
- Features: Core pages and reusable components.
- API integration: `@rest-api-implementation.mdc` (secure CRUD, no mock data).
- Quality: Lint, type safety, zero console errors.
- Build + Serve: Production build and dev server for runtime validation.
- Tests: `@project-testing.mdc` end-to-end with real inputs.

### Tooling routes (use when applicable; keep creativity)

- Testing → `@project-testing.mdc`
- API integration → `@rest-api-implementation.mdc`
- Schema/object ops → `@mcp-tools.mdc`

## Implementation Guidance

- Favor modular, composable components and reusable hooks.
- Prefer reasoning about patterns and intent over rigid templates.
- Leave inferable details implicit; encode only what constrains outcomes.
- DRY and Single Responsibility throughout.
- Mobile-first, accessible interactions.
- Use named ESM exports; prefer async/await with meaningful error handling.
- For forms, prefer `name` over `id` for inputs.

## API Schema Error Handling

Keep this process intact (nuanced and safety-critical):

1. Identify schema-related errors during integration/testing.
2. Retrieve current schema via `mcp_innque_get_schema` or `mcp_innque_find_schema`.
3. Validate against `@schema-structure.mdc` conventions:
   - `snake_case` fields
   - Types: String, Number, Boolean, Date, Array, Pointer, Relation, ACL
   - Required flags and permissions
4. Fix with `mcp_innque_update_schema`:
   - Add missing fields; update mismatched types
   - Align permissions and names with frontend expectations
5. If missing, create with `mcp_innque_create_schema`.
6. Validate fixes via API operations.
7. Update frontend to match corrected schema.

## Quality Standards

- Fulfill stated requirements; maintain consistent, readable code.
- Consistent component patterns; zero console errors in production build.
- Lint clean; build succeeds; E2E tests pass with real data.