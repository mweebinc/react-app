---
alwaysApply: true
---

# Main Orchestrator

## Core Philosophy

**Agentic Coding: Humans Requirements, Agents Code!**

### **Primary Objective**

**Create a production-ready React application based on human requirements.** The AI will analyze human requirements and implement a complete, functional, and deployable application that meets all specified needs.

### **Project Scope Clarification**

**This project focuses exclusively on frontend implementation.** The backend is already implemented using the Innque API, and this React application serves as a frontend client that connects to and consumes the existing Innque API services. No backend development is required.

### **Autonomous Development Approach**

**The AI is fully autonomous and will analyze the current project state to determine what needs to be implemented to achieve a production-ready application.**


### Execution Policy (Do, don't just plan)
- After creating any TODO/plan, **immediately execute Step 1** and continue **sequentially** through all items **without asking**.
- **Do not** end with "Next:" or planning-only summaries. End with either `DONE` (when all steps are finished) or a Stop Condition (see below).
- If rules are referenced, use `fetch_rules` to read the relevant files in `.cursor/rules/` before proceeding.
- **Testing Requests**: When users mention testing, testing requirements, or test-related tasks, use the `@project-testing.mdc` rule for comprehensive end-to-end testing guidance.

### **Requirement Analysis Workflow**

**When a human requests to create something (e.g., "create a POS system"):**

1. **Check Requirements File**: First, check if `requirements.md` exists in the project root
2. **Generate Requirements**: If `requirements.md` doesn't exist, use the `@project-requirements.mdc` rule to generate comprehensive requirements
3. **Analyze Requirements**: Read and analyze the requirements to understand
4. **Create Implementation Plan**: Based on requirements analysis, create a structured implementation plan
5. **Start Implementation**: Begin implementing following the project state analysis workflow below

**Implementation State Analysis:**

1. **Empty Project**: If no React project exists, implement project setup with Vite and Tailwind CSS without postcss
2. **Basic Setup**: If project exists but lacks structure, implement project structure
3. **Structure Ready**: If project structure exists, implement mobile-first responsive components
4. **Components Ready**: If UI components exist, implement core pages and functionality
5. **Frontend Complete**: If frontend is functional, proceed to Innque API integration
6. **Code Quality Check**: Run `npm run lint` to ensure code quality and fix any linting issues
7. **Build Verification**: Run `npm run build` to ensure successful compilation and production readiness
8. **Development Server**: Start development server (runs in background) for runtime testing, ensure to close any existing dev server running on port 3000 first
9. **End-to-End Testing**: Execute comprehensive Puppeteer test suite with actual data inputs and validations (runs in foreground)
10. **git add and git commit**: Ensure all requirements are met and app is deployable

**Implementation Priority:**

- **Project Setup** → **Project Structure** → **Mobile Implementation** → **UI Components** → **Core Pages** → **API Integration** → **Code Quality** → **Build Verification** → **Development Server** → **End-to-End Testing** → **Production Optimization**

### **Automated Workflow Sequence (non-blocking)**

1. **Code Implementation**: Write/update application code per current requirement.
2. **Lint Check**: Run `npm run lint`; fix all issues.
3. **Build Verification**: Run `npm run build` and ensure a successful production build.
4. **Preview (non-watch, time-boxed)**: If a preview is needed, run a non-watch server briefly, e.g. `timeout 120s npx serve -s dist`, then continue.
5. **End-to-End Tests (no watch/UI)**: Run tests in non-watch mode, e.g. `npm test -- --watch=false` or `npx playwright test --reporter=line`. Do **not** use dev servers or watch/UIs here.
6. **Error Detection**: Parse console output; collect and summarize errors/warnings.
7. **Issue Resolution**: Fix detected issues and **repeat 2 → 5** until lint/build/tests pass.
8. **Git Commit**: `git add -A && git commit -m "<concise summary of completed feature>"`.
9. **DONE Output**: Print a concise DONE summary:
   - files changed (paths),
   - brief key diffs,
   - how to run (`build`, `test`, optional preview command).

### **Stop Conditions (the only times you pause)**

1. **Credentials/ENV missing** and cannot proceed safely.
2. **Ambiguous or unsafe fix** required for failing tests/build that needs a human decision.
3. **Tool-call checkpoint reached** (agent often pauses around ~25 tool calls):
   - When this happens, print exactly:
     `PAUSED_AT_TOOLCALL_CHECKPOINT — say "continue" to resume`

### **Implementation Strategy**

- **Production-Ready Focus**: Implement all features required for a deployable application
- **Autonomous Decision Making**: AI analyzes current project state and decides next steps
- **Innque API Integration**: Connect to existing Innque API backend when frontend is ready
- **Mobile-First**: Responsive design with touch interactions
- **Project Structure**: Separation of concerns
- **DRY Principle**: Create reusable components to avoid code duplication
- **Single Responsibility**: Each component and function should have one clear purpose
- **Continuous Progress**: AI proceeds through all stages without mandatory stops
- **No Mock Data**: Avoid creating mock data - implement direct API integration from the start
- **Named Exports**: Use ESM named exports for better tree shaking and explicit imports
- **Async/Await**: Prefer async/await for asynchronous code; handle errors with try/catch and avoid unhandled promise rejections
- **Form Inputs**: Use `name` attribute instead of `id` for all form inputs to ensure proper form handling and accessibility
- **Complete Feature Set**: Ensure all human requirements are fully implemented
- **End-to-End Testing**: Comprehensive functional testing with actual data inputs and validations
- **Quality Assurance**: Automated workflow with lint → build → development server → end-to-end testing

### **Terminal & Long-Running Tasks Policy**

- **Never** run watchers or foreground dev servers during Agent runs:
  - Avoid: `npm run dev`, `vite dev`, `nodemon`, `jest --watch`, `playwright test --ui`.
- Prefer non-watch commands that terminate:
  - Lint: `npm run lint`
  - Build: `npm run build`
  - Tests: `npm test -- --watch=false` or `npx playwright test --reporter=line`
- If a preview is necessary mid-run, use a **time-boxed** static server (e.g., `timeout 120s npx serve -s dist`) and then proceed.

### **Quality Standards**

- **Requirement Fulfillment**: All human requirements must be fully implemented
- **Maintainability**: Clean, readable, and well-documented code
- **Component Consistency**: Maintain consistent design patterns across all UI components
- **Code Quality**: Run `npm run lint` and fix all linting issues before proceeding
- **Build Verification**: Run `npm run build` to ensure successful compilation and production readiness
- **Runtime Quality**: Use comprehensive Puppeteer end-to-end testing to validate all functionality with actual data
- **Error-Free Deployment**: No console errors or warnings in production build

### **API Schema Error Handling**

**When encountering API schema errors (e.g., key mismatches, missing fields, validation errors):**

1. **Identify Schema Issues**: Detect schema-related errors during API integration or testing
2. **Check Current Schema**: Use `mcp_innque_get_schema` or `mcp_innque_find_schema` to retrieve existing collection schema
3. **Analyze Schema Structure**: Review schema against `@schema-structure.mdc` conventions:
   - Verify field naming follows `snake_case` convention
   - Check field types match expected data types (String, Number, Boolean, Date, Array, Pointer, Relation, ACL)
   - Ensure required fields are properly defined
   - Validate permission settings follow `@schema-structure.mdc` patterns
4. **Fix Schema Mismatches**: Use `mcp_innque_update_schema` to correct schema issues:
   - Add missing fields with proper types and properties
   - Update field definitions to match frontend expectations
   - Adjust permissions according to `@schema-structure.mdc` guidelines
   - Ensure field names match frontend code expectations
5. **Create Missing Schemas**: If schema doesn't exist, use `mcp_innque_create_schema` with proper structure
6. **Validate Schema Changes**: Test API operations to ensure schema fixes resolve the errors
7. **Update Frontend Code**: Adjust frontend code if needed to match corrected schema structure

**Common Schema Error Patterns:**
- **Key Mismatch**: Field names in frontend don't match schema field names
- **Missing Fields**: Required fields not defined in schema
- **Type Mismatch**: Frontend expects different data type than schema defines
- **Permission Issues**: Access control rules prevent required operations
- **Validation Errors**: Field constraints not met by data being sent
