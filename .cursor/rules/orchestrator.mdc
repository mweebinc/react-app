---
alwaysApply: true
---

# Main Orchestrator

## Core Philosophy

**Agentic Coding: Humans Requirements, Agents Code!**

### **Primary Objective**

**Create a production-ready React application based on human requirements.** The AI will analyze human requirements and implement a complete, functional, and deployable application that meets all specified needs.

### **Project Scope Clarification**

**This project focuses exclusively on frontend implementation.** The backend is already implemented using the Innque API, and this React application serves as a frontend client that connects to and consumes the existing Innque API services. No backend development is required.

### **Autonomous Development Approach**

**The AI is fully autonomous and will analyze the current project state to determine what needs to be implemented to achieve a production-ready application.**

**Project State Analysis:**
When you cannot directly read other rules, they are located in the `.cursor/rules/` folder. Use the `fetch_rules` tool to retrieve all the rules related to the current human task for implementation guidance.

### **Requirement Analysis Workflow**

**When a human requests to create something (e.g., "create a POS system"):**

1. **Check Requirements File**: First, check if `requirements.md` exists in the project root
2. **Generate Requirements**: If `requirements.md` doesn't exist, use the `@project-requirements.mdc` rule to generate comprehensive requirements
3. **Analyze Requirements**: Read and analyze the requirements to understand:
   - Core functionality needed
   - User roles and permissions
   - Data models and schemas
   - UI/UX requirements
   - Integration points
   - Business logic requirements
4. **Create Implementation Plan**: Based on requirements analysis, create a structured implementation plan
5. **Start Implementation**: Begin implementing following the project state analysis workflow below

**Implementation State Analysis:**

1. **Empty Project**: If no React project exists, implement project setup with Vite and Tailwind CSS without postcss
2. **Basic Setup**: If project exists but lacks structure, implement project structure
3. **Structure Ready**: If project structure exists, implement mobile-first responsive components
4. **Components Ready**: If UI components exist, implement core pages and functionality
5. **Frontend Complete**: If frontend is functional, proceed to Innque API integration
6. **Code Quality Check**: Run `npm run lint` to ensure code quality and fix any linting issues
7. **Build Verification**: Run `npm run build` to ensure successful compilation and production readiness
8. **Development Server**: Start development server (runs in background) for runtime testing, ensure to close any existing dev server running on port 3000 first
9. **End-to-End Testing**: Execute comprehensive Puppeteer test suite with actual data inputs and validations (runs in foreground)
10. **git add and git commit**: Ensure all requirements are met and app is deployable

**Implementation Priority:**

- **Project Setup** → **Project Structure** → **Mobile Implementation** → **UI Components** → **Core Pages** → **API Integration** → **Code Quality** → **Build Verification** → **Development Server** → **End-to-End Testing** → **Production Optimization**

### **Automated Workflow Sequence**

**Quality assurance workflow:**

1. **Code Implementation**: Write/update application code
2. **Lint Check**: `npm run lint` - Fix compile-time issues
3. **Build Verification**: `npm run build` - Ensure production readiness
4. **Development Server**: Start development server, ensure to close any existing dev server running on port 3000 first
5. **End-to-End Testing**: Execute comprehensive Puppeteer test suite with actual data inputs and validations (runs in foreground)
6. **Error Detection**: Monitor console output for runtime issues
7. **Issue Resolution**: Fix any detected errors or warnings
8. **git add and git commit**: Deployable application with no errors

### **Implementation Strategy**

- **Production-Ready Focus**: Implement all features required for a deployable application
- **Autonomous Decision Making**: AI analyzes current project state and decides next steps
- **Innque API Integration**: Connect to existing Innque API backend when frontend is ready
- **Mobile-First**: Responsive design with touch interactions
- **Project Structure**: Separation of concerns
- **DRY Principle**: Create reusable components to avoid code duplication
- **Single Responsibility**: Each component and function should have one clear purpose
- **Continuous Progress**: AI proceeds through all stages without mandatory stops
- **No Mock Data**: Avoid creating mock data - implement direct API integration from the start
- **Named Exports**: Use named exports for better tree shaking and explicit imports
- **Async/Await**: Prefer async/await for asynchronous code; handle errors with try/catch and avoid unhandled promise rejections
- **Form Inputs**: Use `name` attribute instead of `id` for all form inputs to ensure proper form handling and accessibility
- **Complete Feature Set**: Ensure all human requirements are fully implemented
- **End-to-End Testing**: Comprehensive functional testing with actual data inputs and validations
- **Quality Assurance**: Automated workflow with lint → build → development server → end-to-end testing

### **Quality Standards**

- **Requirement Fulfillment**: All human requirements must be fully implemented
- **Maintainability**: Clean, readable, and well-documented code
- **Component Consistency**: Maintain consistent design patterns across all UI components
- **Code Quality**: Run `npm run lint` and fix all linting issues before proceeding
- **Build Verification**: Run `npm run build` to ensure successful compilation and production readiness
- **Runtime Quality**: Use comprehensive Puppeteer end-to-end testing to validate all functionality with actual data
- **Error-Free Deployment**: No console errors or warnings in production build

### **API Schema Error Handling**

**When encountering API schema errors (e.g., key mismatches, missing fields, validation errors):**

1. **Identify Schema Issues**: Detect schema-related errors during API integration or testing
2. **Check Current Schema**: Use `mcp_innque_get_schema` or `mcp_innque_find_schema` to retrieve existing collection schema
3. **Analyze Schema Structure**: Review schema against `@schema-structure.mdc` conventions:
   - Verify field naming follows `snake_case` convention
   - Check field types match expected data types (String, Number, Boolean, Date, Array, Pointer, Relation, ACL)
   - Ensure required fields are properly defined
   - Validate permission settings follow `@schema-structure.mdc` patterns
4. **Fix Schema Mismatches**: Use `mcp_innque_update_schema` to correct schema issues:
   - Add missing fields with proper types and properties
   - Update field definitions to match frontend expectations
   - Adjust permissions according to `@schema-structure.mdc` guidelines
   - Ensure field names match frontend code expectations
5. **Create Missing Schemas**: If schema doesn't exist, use `mcp_innque_create_schema` with proper structure
6. **Validate Schema Changes**: Test API operations to ensure schema fixes resolve the errors
7. **Update Frontend Code**: Adjust frontend code if needed to match corrected schema structure

**Common Schema Error Patterns:**
- **Key Mismatch**: Field names in frontend don't match schema field names
- **Missing Fields**: Required fields not defined in schema
- **Type Mismatch**: Frontend expects different data type than schema defines
- **Permission Issues**: Access control rules prevent required operations
- **Validation Errors**: Field constraints not met by data being sent