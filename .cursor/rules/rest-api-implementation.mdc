---
description: Implement secure CRUD operations with error handling, authentication, and resilience strategies for Innque API integration through reusable usecases.
globs:
alwaysApply: false
---

# REST API Implementation

## Core Philosophy

**Generic over specific**: Build reusable hooks that adapt to any domain rather than creating domain-specific implementations. Focus on **pattern recognition** and **purpose-driven design**.

## Implementation Principles

### API Client Architecture
- **Base URL**: `https://api.innque.com/v1`
- **Authentication**: JWT tokens via secure cookies, fallback to `X-Application-Id`
- **Resilience**: Exponential backoff retry, timeout handling, graceful error recovery
- **Security**: Automatic token management, secure cookie storage, proper CORS handling

### Hook Patterns
- **Generic operations**: `useCreateObject`, `useFindObjects`, `useUpdateObject`, `useDeleteObject`
- **State management**: Loading, error, and data states with abort capabilities
- **Composability**: Hooks should be modular and combinable for complex operations
- **Error boundaries**: Comprehensive error handling with meaningful messages

### Data Flow Patterns
- **Context-driven**: Use AppContext for shared state (user, schemas) to avoid duplicate requests
- **Schema reuse**: Always fetch schemas from context, not individual API calls
- **Protected routes**: Initialize user and schema data at application startup
- **Optimistic updates**: Design for immediate UI feedback with rollback capabilities

## Key Constraints

### Security Requirements
- JWT tokens stored in secure, HTTP-only cookies
- Automatic token refresh and invalidation handling
- Proper authorization header management
- Master key usage only for debugging routes

### Error Handling Standards
- Retry on 5xx errors with exponential backoff
- Network timeout handling (30s default)
- Graceful degradation on authentication failures
- Meaningful error messages with context

### Performance Considerations
- Request cancellation via AbortController
- Efficient query parameter handling
- Minimal re-renders through proper dependency management
- Connection pooling and request deduplication



## Integration Patterns

### Context Integration
```javascript
// Always use context for shared data
const { schemas } = useContext(AppContext);
const schema = schemas.find(s => s.name === collection);
```

### Protected Route Pattern
```javascript
// Initialize user and schemas at app startup
const { user, setUser, setSchemas } = useContext(AppContext);
// Fetch user → fetch schemas → render protected content
```

### Hook Composition
```javascript
// Combine hooks for complex operations
const { create } = useCreateObject();
const { update } = useUpdateObject();
// Implement upsert logic by checking object.id
```

## API Endpoints

### Collections
- `POST /collections/{name}` - Create object
- `GET /collections/{name}` - Find objects (with query params)
- `GET /collections/{name}/{id}` - Get object
- `PUT /collections/{name}/{id}` - Update object
- `DELETE /collections/{name}/{id}` - Delete object
- `GET /count/{name}` - Count objects

### Authentication
- `POST /signup` - User registration
- `POST /signin` - User login
- `GET /me` - Get current user
- `POST /signout` - User logout

### Files & Schemas
- `POST /files/{filename}` - Upload file
- `GET /files/{app-id}/{filename}` - Download file
- `POST /schemas` - Create schema
- `GET /schemas/{name}` - Get schema
- `PUT /schemas/{name}` - Update schema
- `DELETE /schemas/{name}` - Delete schema

## Query Parameters

### Filtering (`where`)
```json
{"field": "value"}                    // Equality
{"field": {"$gt": 10, "$lt": 100}}   // Range
{"field": {"$in": ["a", "b"]}}       // Array
{"$and": [{"a": 1}, {"b": 2}]}       // Complex
```

### Sorting (`sort`)
```json
{"field": 1}    // Ascending
{"field": -1}   // Descending
```

### Pagination
- `limit`: Maximum results
- `skip`: Offset for pagination
- `includes`: Related objects to include
- `keys`: Specific fields to return

### API Client Implementation

```javascript
//src/api.js

const API_BASE = "https://api.innque.com/v1";
const APP_ID = import.meta.env.VITE_APP_ID || "your-application-id";
const MASTER_KEY = import.meta.env.VITE_MASTER_KEY; // only for debug routes
const DEFAULT_RETRIES = 3; // Number of retry attempts

// —————— Native Cookie Helpers ——————
function setCookie(name, value, days = 365) {
  const expires = new Date(Date.now() + days * 864e5).toUTCString();
  document.cookie = [
    `${encodeURIComponent(name)}=${encodeURIComponent(value)}`,
    `expires=${expires}`,
    `path=/`,
    `Secure`, // send only over HTTPS
    `SameSite=Strict`, // adjust: Lax or None as needed
  ].join("; ");
}
function getCookie(name) {
  return document.cookie.split("; ").reduce((value, pair) => {
    const [key, val] = pair.split("=");
    return decodeURIComponent(key) === name ? decodeURIComponent(val) : value;
  }, null);
}
function deleteCookie(name) {
  document.cookie = `${encodeURIComponent(name)}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/`;
}

// —————— JWT Helpers ——————
function saveToken(token) {
  setCookie("jwt", token); // defaults to 365 days
}
function getToken() {
  return getCookie("jwt");
}
function clearToken() {
  deleteCookie("jwt");
}
// —————— Utility: Delay for backoff ——————
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
// —————— Core Fetch Wrapper with Retry ——————
async function request(path, { method = "GET", body = null, headers: customHeaders, retries = DEFAULT_RETRIES, timeout = 30000, signal } = {}) {
  const url = `${API_BASE}${path}`;
  // Recursive dispatch function
  async function dispatch(attempt) {
    const headers = new Headers(customHeaders);
    // Only set default Content-Type if not already set and body is not a Blob
    if (!headers.has("Content-Type") && !(body instanceof Blob)) {
      headers.set("Content-Type", "application/json");
    }
    const token = getToken();
    if (token) {
      headers.set("Authorization", `Bearer ${token}`);
    } else {
      headers.set("X-Application-Id", APP_ID);
    }
    if (MASTER_KEY) {
      headers.set("X-Master-Key", MASTER_KEY);
    }
    const opts = { method, headers };
    if (body != null) {
      // Only stringify if it's not already a string or Blob
      opts.body = body instanceof Blob || typeof body === "string" ? body : JSON.stringify(body);
    }
    if (signal) {
      opts.signal = signal;
    }
    try {
      // Create timeout promise
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error(`Request timeout after ${timeout}ms`)), timeout);
      });
      // Create fetch promise
      const fetchPromise = fetch(url, opts);
      // Race between fetch and timeout
      const res = await Promise.race([fetchPromise, timeoutPromise]);
      // Retry on 5xx
      if (res.status >= 500 && attempt < retries) {
        const backoff = Math.pow(2, attempt) * 200 + Math.random() * 100;
        await delay(backoff);
        return dispatch(attempt + 1);
      }
      if (!res.ok) {
        const errBody = await res.json().catch(() => ({}));
        if (errBody.message === "Invalid session token") {
          clearToken();
        }
        throw new Error(errBody.message || `${res.status} ${res.statusText}`);
      }
      return res.status === 204 ? null : res.json();
    } catch (err) {
      console.error("[API_ERROR]", {url,method, message: err?.message || String(err) });
      // Retry on timeout or network errors
      if ((err instanceof TypeError || /network/i.test(err.message) || /timeout/i.test(err.message)) && attempt < retries) {
        const backoff = Math.pow(2, attempt) * 200 + Math.random() * 100;
        await delay(backoff);
        return dispatch(attempt + 1);
      }
      throw err;
    }
  }
  return dispatch(0);
}

// —————— Collections API ——————
export const createObject = (collection, data, options) => {
  if (!collection) throw new Error("Collection name is required");
  if (!data || typeof data !== "object") throw new Error("Data must be an object");
  return request(`/collections/${collection}`, { method: "POST", body: data, ...options });
};
export const findObjects = (collection, { where, limit, skip, sort, includes, keys } = {}, options) => {
  const qp = new URLSearchParams();
  if (where) qp.set("where", JSON.stringify(where));
  if (limit) qp.set("limit", limit);
  if (skip) qp.set("skip", skip);
  if (sort) qp.set("sort", JSON.stringify(sort));
  if (includes) qp.set("includes", JSON.stringify(includes));
  if (keys) qp.set("keys", JSON.stringify(keys));
  return request(`/collections/${collection}?${qp.toString()}`, options);
};
export const getObject = (collection, id, options) => request(`/collections/${collection}/${id}`, options);
export const updateObject = (collection, data, options) => request(`/collections/${collection}/${data.id}`, { method: "PUT", body: data, ...options });
export const deleteObject = (collection, id, options) => request(`/collections/${collection}/${id}`, { method: "DELETE", ...options });
export const countObjects = (collection, where, options) => {
  const qp = where ? `?where=${encodeURIComponent(JSON.stringify(where))}` : "";
  return request(`/count/${collection}${qp}`, options);
};

// —————— Users API ——————
export async function signUp({ username, email, password }, options) {
  const res = await request("/signup", { method: "POST", body: { username, email, password }, ...options });
  if (res.token) saveToken(res.token);
  return res;
}
export async function signIn({ username, password }, options) {
  const res = await request("/signin", { method: "POST", body: { username, password }, ...options });
  if (res.token) saveToken(res.token);
  return res;
}
export async function signOut(options) {
  try {
    await request("/signout", { method: "POST", ...options });
  } catch (error) {
    console.error(error.message);
  } finally {
    clearToken();
  }
}
export const getCurrentUser = (options) => request("/me", options);

// —————— Files API ——————
export async function uploadFile(file, filename = file.name, options) {
  // Convert file to blob if it's not already
  const blob = file instanceof Blob ? file : new Blob([file], { type: file.type });
  const headers = new Headers();
  headers.set("Content-Type", blob.type || "application/octet-stream");
  return request(`/files/${filename}`, {
    method: "POST",
    body: blob,
    headers,
    ...options,
  });
}
// —————— Schemas API ——————
export const createSchema = (schema, options) => request("/schemas", { method: "POST", body: schema, ...options });
export const getSchema = (collection, options) => request(`/schemas/${collection}`, options);
export const getSchemas = (where, options) => {
  const qp = where ? `?where=${encodeURIComponent(JSON.stringify(where))}` : "";
  return request(`/schemas${qp}`, options);
};
export const updateSchema = (schema, options) => request(`/schemas/${schema.collection}`, { method: "PUT", body: schema, ...options });
export const deleteSchema = (collection, options) => request(`/schemas/${collection}`, { method: "DELETE", ...options });
```


### React Hook Pattern Implementation

#### Object Hooks

```javascript
import { useState, useCallback, useRef } from "react";
import { createObject } from "../../api.js";
export function useCreateObject() {
  const [object, setObject] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const abortControllerRef = useRef(null);

  const create = useCallback(async (collection, object, options = {}) => {
    setLoading(true);
    setError(null);
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    abortControllerRef.current = new AbortController();
    try {
      const response = await createObject(collection, object, {
        signal: abortControllerRef.current.signal,
        ...options,
      });
      setObject(response);
      return response;
    } catch (err) {
      if (err.name === "AbortError") {
        console.log("Create object hook was aborted");
        return null;
      }
      const errorMessage = `Create object failed: ${err.message}`;
      setError(new Error(errorMessage));
      throw new Error(errorMessage);
    } finally {
      setLoading(false);
      abortControllerRef.current = null;
    }
  }, []);
  const abort = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }
  }, []);
  return {
    create,
    object,
    loading,
    error,
    abort
  };
}
```

### Directory Structure

```
src/
├── api.js      # Core API client with authentication
└── usecases/
    ├── object/ # Generic CRUD operations
    │   ├── useCreateObject.js
    │   ├── useGetObject.js
    │   ├── useUpdateObject.js
    │   ├── useDeleteObject.js
    │   ├── useFindObjects.js
    │   ├── useUpsertObject.js
    │   └── useCountObjects.js
    ├── schema/ # Schema management
    │   ├── useCreateSchema.js
    │   ├── useGetSchema.js
    │   ├── useFindSchemas.js
    │   ├── useUpdateSchema.js
    │   └── useDeleteSchema.js
    ├── user/  # Authentication flows
    │   ├── useSignUp.js
    │   ├── useSignIn.js
    │   ├── useSignOut.js
    │   └── useGetCurrentUser.js
    └── file/ # File operations
        └── useUploadFile.js
```
