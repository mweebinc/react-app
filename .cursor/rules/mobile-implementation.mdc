---
description: Implement mobile-first responsive design with touch sidebar navigation, Tailwind breakpoints, and accessibility for optimal mobile UX.
alwaysApply: false
---

# üì± Mobile Implementation Architect

## Core Philosophy

- **Mobile as default**: All interfaces designed for mobile first
- **Progressive enhancement**: Scale from mobile to tablet (`md:`) to desktop (`lg:`)
- **Touch-optimized**: Prioritize touch interactions and accessibility
- **Content-driven**: Layout adapts based on content type and available width

---

## üèó Architectural Principles

### Mobile-First Design Foundation

- **Viewport Configuration**: `<meta name="viewport" content="width=device-width, user-scalable=no"/>`
- **Responsive Breakpoints**: Use `lg:` (1024px) for desktop detection

### Responsive Architecture Patterns

- **Content-driven grids**: Single-column for charts/forms, double-column for cards/dashboards on mobile
- **Progressive enhancement**: Scale to multi-column layouts on tablet (`md:`) and desktop (`lg:`)
- **Navigation patterns**: Drawer navigation for mobile, persistent for desktop
- **Context-driven state**: Centralized state management for responsive behavior

### Touch Interaction Design

- **Gesture recognition**: Implement touch gestures and interactions for mobile devices
- **Visual feedback**: Provide immediate feedback for user interactions
- **Performance optimization**: Use CSS transitions over JavaScript, efficient animation frames

### Global Customization Decision Guide

- **Body Width Modifications**: Avoid modifying the width of the body element - other CSS properties are handled by Tailwind CSS
- **Component Styling**: Apply styles through Tailwind classes and component props rather than custom CSS rules
- **Use Custom CSS in index.css for**: Base element styling (fonts, line-height), CSS custom properties, browser resets, global animations, accessibility features, theme switching
- **Use Tailwind Classes for**: Component-specific styling, responsive behavior, interactive states, layout/spacing, visual design variations
- **Decision Framework**: Start with Tailwind ‚Üí Extend with `@apply` when necessary ‚Üí Use custom CSS only for truly global, non-component-specific styles
- **Tailwind Opacity**: Instead of using `bg-opacity-50`, use `opacity-50` for better compatibility and consistency

---

---

## üé® Design Guidelines

### Design Pattern Selection Framework

The AI agent will analyze user requirements and automatically select the most appropriate design pattern based on the application's goals and target audience.

#### Available Design Patterns

**Skeuomorphic Design**
**Flat Design**
**Material Design (Google)**
**Neumorphism (Soft UI)**
**Glassmorphism**
**Minimalist / Clean UI**
**Brutalist Design**
**Dark Mode Design**
**Claymorphism**
**Metro / Fluent Design (Microsoft)**
**Gamification UI**

### Implementation Guidelines

- **Design Consistency**: Once a design pattern is selected, maintain consistency throughout the application
- **Accessibility First**: Ensure all design patterns meet WCAG guidelines regardless of aesthetic choice
- **Performance Consideration**: Balance visual appeal with loading speed and responsiveness
- **User Testing**: Design patterns should be validated against target user preferences

---

## üé® Icon Strategy

### Icon Selection Framework

- **Navigation menus**: Emoji for universal recognition
- **Action buttons**: Inline SVG for customization and accessibility
- **Status indicators**: Emoji for emotional context and universal meaning
- **Complex features**: SVG Assets for consistency and performance
- **Brand elements**: Inline SVG for full control and scalability
- **Quick prototypes**: Emoji for fast implementation

---

### Implementation Guidelines

- **Navbar**: Place bulk actions (Import, Export, Delete) in dropdown menu
- **FAB**: Use circular floating action button for "Add" in bottom-right corner on list pages
- **Form Actions**: Use Save/Cancel buttons at bottom of form pages
- **Tables**: Show minimal info (name, status) by default, expand on tap for full details
- **No Horizontal Scroll**: Eliminate horizontal scrolling on mobile devices
- **Avoid Duplicate Actions**: Prevent duplicate action buttons across different UI areas (e.g., don't have Save button in both form and Navbar)

## Key Implementation Rules

1. **Always start with mobile-first responsive design**
2. **Implement touch gesture systems for mobile interactions**
3. **Use CSS transitions over JavaScript for smooth animations**
4. **Maintain consistent design patterns across screen sizes**
5. **Ensure consistent text and background colors across mobile and desktop**

---

## üîß JavaScript Implementation Details

### useScreenSize Hook Implementation

```javascript
//hooks/useScreenSize.js
function useScreenSize() {
  const [isMobile, setIsMobile] = useState(window.innerWidth < 1024);
  // Add resize listener and cleanup
  return isMobile;
}
```

### MainLayout Component Implementation

```javascript
//src/components/MainLayout.jsx
const Context = createContext();
function MainLayout({ children,menus }) {
  const isMobile = useScreenSize();
  const [show, setShow] = useState(!isMobile);
  useEffect(() => {
    setShow(!isMobile);
  }, [isMobile]);

  const mainContentStyle = isMobile
    ? {}
    : {
        marginLeft: show ? "270px" : "0px",
        transition: "margin-left 0.3s ease-in-out",
      };
  return (
    <Context.Provider value={{ show, setShow, isMobile }}>
      <div style={mainContentStyle} className="min-h-screen">
        <Sidebar show={show} onSetShow={setShow}>
          <NavSidebar
            className="lg:w-[270px]"
            menus={menus}
            isMobile={isMobile}
            setShow={setShow}
          />
        </Sidebar>
        {children}
      </div>
    </Context.Provider>
  );
}
MainLayout.Context = Context;
```

### MainPage.jsx Rendering Pattern

- **Layout Integration**: Wrap main page content with MainLayout component
- **Context Consumer Pattern**: Use MainLayout.Context.Consumer for sidebar state access
- **Routing Setup**: Implement React Router Routes within main content area

```javascript
//src/pages/MainPage.jsx
render() {
  return (
    <MainLayout menus={menus}>
      <Routes>
        <Route path={"/"} element={<Dashboard/>}/>
        <Route path="/collections/:collection" element={<CollectionListPage />} />
        <Route path="/collections/:collection/form" element={<CollectionFormPage />} />
        <Route path="/collections/:collection/form/:id" element={<CollectionFormPage />} />
      </Routes>
    </MainLayout>
  );
}
```

### Navbar Component Implementation

- **Page-Level Import**: Import Navbar in individual pages
- **Custom Actions**: Children prop allows page-specific button
- **Loading State**: Animated loading indicator
- **Sticky Positioning**: `sticky top-0` for persistent navigation
- **No lg:hidden**: Avoid using `lg:hidden` classes in Navbar components to maintain consistent hamburger menu functionality across all screen sizes

```javascript
const Navbar = ({ title = "App", children, loading = false }) => {
  const contextValue = React.useContext(MainLayout.Context);
  const { show, setShow } = contextValue;
  function onClickToggle() {
    setShow(!show);
  }
};
```

### Sidebar Implementation Features

- **Context Integration**: Uses MainLayout.Context for sidebar state management

```javascript
function Sidebar({
  show = false,
  onSetShow,
  position = "left",
  children,
  className = "",
  dragToggleDistance = 30,
  touchHandleWidth = 20,
}) {
  const [isDragging, setIsDragging] = useState(false);
  const [touchStartX, setTouchStartX] = useState(null);
  const [touchCurrentX, setTouchCurrentX] = useState(null);
  const [sidebarWidth, setSidebarWidth] = useState(0);
  const [touchSupported, setTouchSupported] = useState(false);
  const sidebarRef = useRef(null);
  const animationFrameRef = useRef(null);

  useEffect(() => {
    setTouchSupported(typeof window === "object" && "ontouchstart" in window);
  }, []);

  useEffect(() => {
    if (sidebarRef.current) setSidebarWidth(sidebarRef.current.offsetWidth);
  }, [children]);

  const getMovePercent = () => {
    if (!touchStartX || !touchCurrentX || !sidebarWidth) return 0;
    if (position === "right") {
      return show
        ? Math.max(
            0,
            Math.min(
              100,
              ((touchStartX - touchCurrentX + sidebarWidth) / sidebarWidth) *
                100
            )
          )
        : Math.max(
            0,
            Math.min(
              100,
              ((window.innerWidth - touchCurrentX) / sidebarWidth) * 100
            )
          );
    }
    return show
      ? Math.max(
          0,
          Math.min(
            100,
            ((touchCurrentX - touchStartX + sidebarWidth) / sidebarWidth) * 100
          )
        )
      : Math.max(0, Math.min(100, (touchCurrentX / sidebarWidth) * 100));
  };

  const percentage = getMovePercent();

  useEffect(() => {
    if (!touchSupported) return;

    const handleTouchMove = (e) => {
      if (isDragging) {
        e.preventDefault();
        if (animationFrameRef.current)
          cancelAnimationFrame(animationFrameRef.current);
        animationFrameRef.current = requestAnimationFrame(() =>
          setTouchCurrentX(e.touches[0].clientX)
        );
      }
    };

    const handleTouchEnd = () => {
      if (isDragging) {
        if (
          (show && percentage < 100 - dragToggleDistance) ||
          (!show && percentage > dragToggleDistance)
        ) {
          onSetShow(!show);
        }
        setIsDragging(false);
        setTouchStartX(null);
        setTouchCurrentX(null);
        if (animationFrameRef.current) {
          cancelAnimationFrame(animationFrameRef.current);
          animationFrameRef.current = null;
        }
      }
    };

    document.addEventListener("touchmove", handleTouchMove, { passive: false });
    document.addEventListener("touchend", handleTouchEnd);

    return () => {
      document.removeEventListener("touchmove", handleTouchMove);
      document.removeEventListener("touchend", handleTouchEnd);
      if (animationFrameRef.current)
        cancelAnimationFrame(animationFrameRef.current);
    };
  }, [
    touchSupported,
    isDragging,
    show,
    onSetShow,
    dragToggleDistance,
    percentage,
  ]);

  const handleTouchStart = (e) => {
    if (!touchSupported || isDragging) return;
    const touch = e.touches[0];
    if (show && sidebarRef.current) {
      const rect = sidebarRef.current.getBoundingClientRect();
      const isNearEdge =
        position === "left"
          ? touch.clientX >= rect.right - 40
          : touch.clientX <= rect.left + 40;
      if (!isNearEdge) return;
    }
    setIsDragging(true);
    setTouchStartX(touch.clientX);
    setTouchCurrentX(touch.clientX);
  };

  const getTransform = () => {
    if (isDragging)
      return position === "right"
        ? `translateX(${100 - percentage}%)`
        : `translateX(-${100 - percentage}%)`;
    return position === "right"
      ? show
        ? "translateX(0%)"
        : "translateX(100%)"
      : show
      ? "translateX(0%)"
      : "translateX(-100%)";
  };

  const shouldShowDragHandle = touchSupported && !show;
  const isRight = position === "right";

  return (
    <>
      {shouldShowDragHandle && (
        <div
          className={`fixed top-0 bottom-0 z-50 touch-manipulation lg:hidden ${
            isRight ? "right-0" : "left-0"
          }`}
          style={{ width: touchHandleWidth }}
          onTouchStart={handleTouchStart}
        />
      )}
      {touchSupported && (
        <div
          className={`fixed inset-0 z-50 transition-opacity duration-300 ease-in-out ${
            show
              ? "opacity-100 visible pointer-events-auto"
              : "opacity-0 invisible pointer-events-none"
          }`}
          style={
            isDragging
              ? {
                  opacity: percentage / 100,
                  transition: "none",
                  visibility: "visible",
                  pointerEvents: "auto",
                  backgroundColor: "rgba(0,0,0,0.3)",
                }
              : { backgroundColor: "rgba(0,0,0,0.3)" }
          }
          onClick={() => onSetShow?.(false)}
        />
      )}

      <div
        ref={sidebarRef}
        className={`fixed top-0 h-full z-50 lg:z-30 shadow-lg overflow-y-auto ${
          isRight ? "right-0" : "left-0"
        } ${className}`}
        style={{
          transform: getTransform(),
          WebkitTransform: getTransform(),
          transition: isDragging
            ? "transform 0s ease-in-out"
            : "transform 300ms ease-in-out",
        }}
        onTouchStart={shouldShowDragHandle ? undefined : handleTouchStart}
      >
        {children}
      </div>
    </>
  );
}
```

## üß™ Implementation Guidelines

### NavSidebar Component Implementation

- **Menu item click behavior**: When menu items are clicked, set show to false to close the sidebar on mobile devices

```javascript
function NavSidebar({ isMobile, setShow }) {
  const handleNavClick = () => {
    if (isMobile) {
      setShow(false);
    }
  };
}
```
